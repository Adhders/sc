# Order and sales statistics in e-commerce scenarios {#concept_65670_zh .concept}

This topic provides a use case to describe how to use Realtime Compute to collect order and sales statistics.

## Background {#section_x45_r1l_2gb .section}

The following use case describes how Kangaroo Cloud, a partner of Realtime Compute, manages e-commerce orders through Realtime Compute.

## Business architecture {#section_qms_cbl_2gb .section}

![](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/41087/155764842934717_en-US.png)

The business process is as follows:

1.  Synchronize your data to DataHub through Alibaba Cloud Data Transmission Service \(DTS\). For more information, see [Real-time data synchronization from MySQL to DataHub](https://help.aliyun.com/document_detail/45214.html).
2.  Use Realtime Compute to subscribe to data in DataHub for real-time computing.
3.  Insert real-time data into RDS.
4.  Display data in Alibaba Cloud DataV or other visual dashboards.

## Preparations {#section_hvd_dbl_2gb .section}

Synchronize the incremental data generated by ApsaraDB RDS for MySQL to your specified topic in tables in the DataHub schema in real time.

For more information, see [Real-time data synchronization from MySQL to DataHub](https://help.aliyun.com/document_detail/45214.html?spm=5176.doc26633.6.602.o8AntI).

The following table describes the fields in a source order table.

|Field name|Data type|Description|
|----------|---------|-----------|
|dts\_ordercodeofsys|VARCHAR|The ID of the order.|
|dts\_paytime|VARCHAR|The payment time of the order.|
|dts\_deliveredtime|VARCHAR|The delivery time in the order.|
|dts\_storecode|VARCHAR|The ID of the store.|
|dts\_warehousecode|VARCHAR|The ID of the warehouse.|
|dts\_cancelled|BIGINT|Indicates whether the order has been canceled.|
|dts\_delivered|BIGINT|Indicates whether the product has been delivered.|
|dts\_receivercity|VARCHAR|The city where the consignee is located.|
|dts\_receiverprovince|VARCHAR|The province where the consignee is located.|
|dts\_record\_id|VARCHAR|The ID of the record.|
|dts\_operation\_flag|VARCHAR|The flag of the operation.|
|dts\_instance\_id|VARCHAR|The database instance ID.|
|dts\_db\_name|VARCHAR|The name of the database.|
|dts\_table\_name|VARCHAR|The name of the table.|
|dts\_utc\_timestamp|VARCHAR|The time when the record was last updated.|
|dts\_before\_flag|VARCHAR|Indicates whether the column values are the pre-update values.|
|dts\_after\_flag|VARCHAR|Indicates whether the column values are the post-update values.|

The following table describes the fields in a source table of order details.

|Field name|Data type|Description|
|----------|---------|-----------|
|dts\_ordercodeofsys|VARCHAR|The ID of the order.|
|dts\_skuname|VARCHAR|The name of the product.|
|dts\_skucode|VARCHAR|The ID of the product.|
|dts\_quantity|BIGINT|The ordered quantity of the product.|
|dts\_dividedamount|DOUBLE|The amount on the invoice.|
|dts\_salechanneldividedamount|DOUBLE|The sales amount of the marketing channel.|
|dts\_initialcost|DOUBLE|The cost.|
|dts\_record\_id|VARCHAR|The ID of the record.|
|dts\_operation\_flag|VARCHAR|The flag of the operation.|
|dts\_instance\_id|VARCHAR|The database instance ID.|
|dts\_db\_name|VARCHAR|The name of the database.|
|dts\_table\_name|VARCHAR|The name of the table.|
|dts\_utc\_timestamp|VARCHAR|The time when the record was last updated.|
|dts\_before\_flag|VARCHAR|Indicates whether the column values are the pre-update values.|
|dts\_after\_flag|VARCHAR|Indicates whether the column values are the post-update values.|

## Business logic {#section_xvr_dbl_2gb .section}

```language-sql
// Create source tables.
create table orders_real(
dts_ordercodeofsys VARCHAR,
dts_paytime VARCHAR,
dts_deliveredtime VARCHAR,
dts_storecode VARCHAR,
dts_warehousecode VARCHAR,
dts_cancelled BIGINT,
dts_delivered BIGINT,
dts_receivercity VARCHAR,
dts_receiverprovince VARCHAR,
dts_record_id VARCHAR,
dts_operation_flag VARCHAR,
dts_instance_id VARCHAR,
dts_db_name VARCHAR,
dts_table_name VARCHAR,
dts_utc_timestamp VARCHAR,
dts_before_flag VARCHAR,
dts_after_flag VARCHAR
)with(
type='datahub',
endPoint='http://dh-cn-****.com',
project='yourProjectName',
topic='yourTableName',
accessId='yourAccessId',
accessKey='yourAccessSecret'
);

create table orderdetail_real(
dts_ordercodeofsys VARCHAR,
dts_skuname VARCHAR,
dts_skucode VARCHAR,
dts_quantity BIGINT,
dts_dividedamount DOUBLE,
dts_salechanneldividedamount DOUBLE,
dts_initialcost DOUBLE,
dts_record_id VARCHAR,
dts_operation_flag VARCHAR,
dts_instance_id VARCHAR,
dts_db_name VARCHAR,
dts_table_name VARCHAR,
dts_utc_timestamp VARCHAR,
dts_before_flag VARCHAR,
dts_after_flag VARCHAR
)with(
type='datahub',
endPoint='http://dh-cn-****.com',
project='yourProjectName',
topic='yourTableName',
accessId='yourAccessId',
accessKey='yourAccessSecret'
);


create table ads_all_count_amount(
bill_date VARCHAR, // The time when the order was placed.
bill_count BIGINT, // The total number of orders.
qty BIGINT, // The total sales volume.
primary key (bill_date)
)with(
type='rds',
url='jdbc:mysql://rm-****.mysql.rds.aXXXXcs.com:3306/****',
tableName='yourDatabaseTableName',
userName='yourDatabaseUserName',
password='yourDatabasePassword'
);

// Create the new_paytime table, which stores the product ID of the latest transaction time.
CREATE VIEW new_paytime AS
SELECT
dts_ordercodeofsys,
MAX(dts_paytime) AS dts_paytime
    FROM orders_real
    GROUP BY dts_ordercodeofsys

// Create the new_orderdetail table, which stores the order ID, product name, product ID, and quantity in each valid order.
CREATE VIEW new_orderdetail AS
SELECT
dts_ordercodeofsys,
dts_skuname,
dts_skucode,
CASE WHEN dts_operation_flag='U'
        AND dts_before_flag='Y'
        AND dts_after_flag='N' THEN -1*dts_quantity
    WHEN dts_operation_flag='U'
        AND dts_before_flag='N'
        AND dts_after_flag='Y' THEN dts_quantity
    WHEN dts_operation_flag='D' THEN -1*dts_quantity
    ELSE dts_quantity
    END AS dts_quantity
        FROM
orderdetail_real

// Collect statistics on the total number of orders and total sales volume.
INSERT INTO ads_all_count_amount
SELECT
    from_unixtime(CAST(a.dts_paytimeASBIGINT)/1000000,'yyyyMMdd') AS bill_date,
    COUNT(DISTINCTa.dts_ordercodeofsys) AS bill_count,
    SUM(b.dts_quantity) AS qty
from
    (new_paytime) a
join
    (new_orderdetail) b
ON a.dts_ordercodeofsys=b.dts_ordercodeofsys
GROUP BY
from_unixtime(CAST(a.dts_paytimeASBIGINT)/1000000,'yyyyMMdd')
```

## Key points {#section_onw_hpl_2gb .section}

To help you understand structured code and facilitate code maintenance, we recommend that you use views to split the business logic into three modules. For more information about views, see [Create a data view](../../../../intl.en-US/Flink SQL Development Guide/Flink SQL/Create a data view.md#).

-   Module 1

    Group data by order ID.

    An order ID is associated with multiple business operations such as ordering, payment, and delivery. For these operations, multiple order records with the same order ID are generated in the binlog file. Use `MAX(dts_paytime)` to obtain the time when the last payment record of an order was generated in the database.

    ```language-sql
    CREATE VIEW new_paytime AS
    SELECT
        dts_ordercodeofsys,
        MAX(dts_paytime) AS dts_paytime
    FROM orders_real
    GROUP BY dts_ordercodeofsys
    ```

-   Module 2

    Generate valid order information.

    ```
    // Create the new_orderdetail table, which stores the order ID, product name, product ID, and quantity in each valid order.
    CREATE VIEW new_orderdetail AS
    SELECT
    dts_ordercodeofsys,
    dts_skuname,
    dts_skucode,
    CASE WHEN dts_operation_flag='U'
            AND dts_before_flag='Y'
            AND dts_after_flag='N' THEN -1*dts_quantity
        WHEN dts_operation_flag='U'
            AND dts_before_flag='N'
            AND dts_after_flag='Y' THEN dts_quantity
        WHEN dts_operation_flag='D' THEN -1*dts_quantity
        ELSE dts_quantity
        END AS dts_quantity
            FROM orderdetail_real
    ```

    All changes to data records are logged in the database. Each order is stateful. The following table describes the fields in a database log.

    |Field name|Data type|Description|
    |----------|---------|-----------|
    |dts\_record\_id|VARCHAR|The unique ID of the incremental log, which auto-increments with each log. If an Update operation is performed on a record, two records are generated: one inserted record and one deleted record. The two records have the same `record_id` value.|
    |dts\_operation\_flag|VARCHAR| The operation type of the incremental log. Valid values:

     -   I: insert
    -   D: delete
    -   U: update
 |
    |dts\_instance\_id|VARCHAR|The database `instance ID`. The instance ID of the database for which the incremental log records operations.|
    |dts\_db\_name|VARCHAR|The name of the database where the updated table recorded in the incremental log is located.|
    |dts\_table\_name|VARCHAR|The name of the updated table that is recorded in the incremental log.|
    |dts\_utc\_timestamp|VARCHAR|The timestamp when the operation in the incremental log is recorded in the binlog file. The timestamp uses UTC time.|
    |dts\_before\_flag|VARCHAR|Indicates whether the column values that follow the incremental log are those before the update. Valid values: `Y` and `N`. `dts_before_flag` is Y when the column values that follow the incremental log are the pre-update values. `dts_before_flag` is N when the column values that follow the incremental log are the post-update values.|
    |dts\_after\_flag|VARCHAR|Indicates whether the column values that follow the incremental log are those after the update. Valid values: `Y` and `N`. `dts_after_flag` is N when the column values that follow the incremental log are the pre-update values. `dts_after_flag` is Y when the column values that follow the incremental log are the post-update values.|

    The `dts_before_flag` and `dts_after_flag` values in an incremental log vary with different operation types:

    1.  Insert operation

        For an Insert operation, the column values that follow the incremental log are the newly inserted record values, namely, post-update values. Therefore, `dts_before_flag` is N, and `dts_after_flag` is Y.

        ![](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/41087/155764842934718_en-US.png)

    2.  Update operation

        When an Update operation is performed, two incremental logs are generated. The two incremental logs have the same `dts_record_id`, `dts_operation_flag`, and `dts_utc_timestamp` values. The first log records the pre-update values, so `dts_before_flag` is Y and `dts_after_flag` is N. The second log records the post-update values, so `dts_before_flag` is N and `dts_after_flag` is Y.

        ![](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/41087/155764842934719_en-US.png)

    3.  Delete operation

        For a Delete operation, the column values that follow the incremental log are the deleted record values, namely, pre-update values. Therefore, `dts_before_flag` is Y, and `dts_after_flag` is N.

        ![](http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/41087/155764842934721_en-US.png)

    **Note:** 

    Q: How can I determine a valid order?

    A: For a valid order, `dts_operation_flag` is `U` or I, `dts_before_flag` specifies the pre-update order status, and `dts_after_flag` specifies the post-update order status. To conclude, a valid order is defined as follows:

    ```language-sql
    dts_operation_flag='U'
            AND dts_before_flag='N'
            AND dts_after_flag='Y' THEN dts_quantity
    ```

    Q: Why is `THEN -1*dts_quantity` used?

    A: Canceled orders and failed orders are counted in the total sales volume. To ensure the accuracy of the total sales volume, the number of these orders is set to negative to remove the number from the total sales volume.

-   Module 3

    Collect statistics on the total number of orders and the total sales volume.

    ```language-SQL
    SELECT
        from_unixtime(CAST(a.dts_paytimeASBIGINT)/1000000,'yyyyMMdd') AS bill_date,
        COUNT(DISTINCTa.dts_ordercodeofsys) AS bill_count,
        SUM(b.dts_quantity) AS qty
    from
        (new_paytime) a
    join
        (new_orderdetail) b
    ON
        a.dts_ordercodeofsys=b.dts_ordercodeofsys
    GROUP BY
    from_unixtime(CAST(a.dts_paytimeASBIGINT)/1000000,'yyyyMMdd');
    ```

    Q: Why do I need to join the source order table and order details table?

    A: The `new_paytime` table stores all the order IDs of the latest transaction time. The `new_orderdetail` table stores the order ID, product name, product ID, and quantity in each valid order. The two tables are joined to help you collect statistics on the total number of orders and the total sales volume.


